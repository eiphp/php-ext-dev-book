# Debugging

Things will not always work and C is more difficult than PHP. So how do you
debug a problem? For example:

## Segfaults

I changed the function to print "hello" with an uppercase "H", but made a programming mistake.

```c
/* for toupper() */
#include <ctype.h>

PHP_FUNCTION(hello) {
  char *name = NULL;
  char *hello = "hello";
  size_t name_len = 0;

  hello[0] = toupper(hello[0]);

  if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &name, &name_len) == FAILURE) {
      return;
  }

  php_printf("%s %s\n", hello, name);
  RETURN_TRUE;
}
```

Let's see what happens when we run it:

```
$ php -dextension=modules/hello.so -a
Interactive shell

php > hello('world');
Segmentation fault
```

Now what?

### Get a coredump

Enable coredumps and run the program again:

```
ulimit -c unlimited
```

```
$ php -dextension=modules/hello.so -r "hello('world');"
Segmentation fault (core dumped)
```

A file named ```core``` will be created.

### Locating the problem

Run the GNU debugger on php with your coredump.

```
$ gdb php core
...
Core was generated by `php -dextension=modules/hello.so -r hello('world');'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fe35992896e in zif_hello (execute_data=0x7fe35a6130a0, return_value=0x7fe35a613090) at .../manuscript/CoreDump/hello.c:42
42	  hello[0] = toupper(hello[0]);
```

It immediately points out that there is a problem with the ```toupper()``` in ```hello.c``` at line 42.
It will not always be this obvious, sometimes you want to get a backtrace to see how you got at this line. Run ```bt``` to get a full stack trace:

```
(gdb) bt
#0  0x00007fe35992896e in zif_hello (execute_data=0x7fe35a6130a0, return_value=0x7fe35a613090) at .../manuscript/CoreDump/hello.c:42
#1  0x0000000000b052d8 in ZEND_DO_ICALL_SPEC_HANDLER () at .../Zend/zend_vm_execute.h:586
#2  0x0000000000b04d04 in execute_ex (ex=0x7fe35a613030) at .../Zend/zend_vm_execute.h:414
#3  0x0000000000b04e15 in zend_execute (op_array=0x7fe35a682000, return_value=0x7ffc179a0af0) at .../Zend/zend_vm_execute.h:458
#4  0x0000000000a8ea37 in zend_eval_stringl (str=0x1b1a680 "hello('world');", str_len=15, retval_ptr=0x0, string_name=0x1138ae4 "Command line code")
    at .../Zend/zend_execute_API.c:1135
#5  0x0000000000a8ec5c in zend_eval_stringl_ex (str=0x1b1a680 "hello('world');", str_len=15, retval_ptr=0x0, string_name=0x1138ae4 "Command line code",
    handle_exceptions=1) at .../Zend/zend_execute_API.c:1176
#6  0x0000000000a8ece2 in zend_eval_string_ex (str=0x1b1a680 "hello('world');", retval_ptr=0x0, string_name=0x1138ae4 "Command line code", handle_exceptions=1)
    at .../Zend/zend_execute_API.c:1187
#7  0x0000000000b6df9d in do_cli (argc=4, argv=0x1b3dcb0) at .../sapi/cli/php_cli.c:1005
#8  0x0000000000b6f065 in main (argc=4, argv=0x1b3dcb0) at .../sapi/cli/php_cli.c:1344
```

You can also step debug it. Run the program again under gdb and set a breakpoint on line 38.

```
$ gdb --args php -dextension=modules/hello.so -r "hello('world');"
...
(gdb) break hello.c:38
No source file named hello.c.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (hello.c:38) pending.
```

Then actually run the program and step through it.

```
(gdb) run
Starting program: php -dextension=modules/hello.so -r hello\(\'world\'\)\;

Breakpoint 1, zif_hello (execute_data=0x7fffecc130a0, return_value=0x7fffecc13090) at .../manuscript/CoreDump/hello.c:38
38	  char *name = NULL;
(gdb) s
39	  char *hello = "hello";
(gdb) s
40	  size_t name_len = 0;
(gdb) s
42	  hello[0] = toupper(hello[0]);
(gdb) print hello
$1 = 0x7fffebf28a09 "hello"
(gdb) s
toupper (c=104) at ctype.c:52
52	  return c >= -128 && c < 256 ? __ctype_toupper[c] : c;
(gdb) s
53	}
(gdb) s

Program received signal SIGSEGV, Segmentation fault.
0x00007fffebf2896e in zif_hello (execute_data=0x7fffecc130a0, return_value=0x7fffecc13090) at .../manuscript/CoreDump/hello.c:42
42	  hello[0] = toupper(hello[0]);
```

The problem with the program is that the ```char *hello = "hello";``` should have been a ```char hello[] = "hello";```.
Rookie mistake, read "The C programming language" (K&R) section 5.5 "Character Pointers and Functions" for more information.

## Memory leaks

Let's make the function leak memory by allocating 128 bytes of memory and not releasing them:

```c
PHP_FUNCTION(hello) {
  char *name = NULL;
  size_t name_len = 0;

  emalloc(128);

  if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &name, &name_len) == FAILURE) {
      return;
  }

  php_printf("Hello %s\n", name);
  RETURN_TRUE;
}
```

Let's see what happens when we run it:

```
$ php -dextension=modules/hello.so -r "hello('world');"
Hello world
[Sun Jul 24 17:30:07 2016]  Script:  '-'
.../manuscript/CoreDump/hello.c(38) :  Freeing 0x7F25B10731E0 (128 bytes), script=-
=== Total 1 memory leaks detected ===
```

If PHP is built with ```--enable-debug``` and the ini flag ```report_memleaks``` is ```On``` (this is by default), memory leaks will be reported.
You can turn it off and PHP will no longer print info about the leak:

```
$ php -dreport_memleaks=Off -dextension=modules/hello.so -r "hello('world');"
Hello world
```

The reason why the engine detects the leak is because ```emalloc()``` is part of the PHP API and it tracks allocations.
Never use the system default allocators like ```malloc()``` to work with memory, the engine will not detect leaks.
More information about PHP memory API at http://php.net/manual/en/internals2.memory.management.php

Tools like Valgrind can help you debug memory leaks.

### Valgrind

Note: I compiled Valgrind from source because the latest version has a bug that makes it unusable.
See http://valgrind.org/downloads/repository.html for instructions.

Make sure to turn off Zend Memory Manager (ZMM) when debugging leaks with Valgrind.
It will force the system to use the default system allocators.

Also make sure Zend doesn't unload the modules. Otherwise Valgrind will have gaps in it's output.
It will try to make a report but the modules are already gone.

```
$ ZEND_DONT_UNLOAD_MODULES=1 USE_ZEND_ALLOC=0 valgrind --leak-check=yes php -dextension=modules/hello.so -r "hello('world');"
==30599== Memcheck, a memory error detector
==30599== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==30599== Using Valgrind-3.12.0.SVN and LibVEX; rerun with -h for copyright info
==30599== Command: php -dextension=modules/hello.so -r hello('world');
==30599==
Hello world
==30599==
==30599== HEAP SUMMARY:
==30599==     in use at exit: 80,645 bytes in 42 blocks
==30599==   total heap usage: 31,207 allocs, 31,165 frees, 3,639,418 bytes allocated
==30599==
==30599== 128 bytes in 1 blocks are definitely lost in loss record 30 of 38
==30599==    at 0x4C2DBB6: malloc (vg_replace_malloc.c:299)
==30599==    by 0xA70761: _emalloc (zend_alloc.c:2446)
==30599==    by 0x10C4397C: zif_hello (hello.c:38)
==30599==    by 0xB052D7: ZEND_DO_ICALL_SPEC_HANDLER (zend_vm_execute.h:586)
==30599==    by 0xB04D03: execute_ex (zend_vm_execute.h:414)
==30599==    by 0xB04E14: zend_execute (zend_vm_execute.h:458)
==30599==    by 0xA8EA36: zend_eval_stringl (zend_execute_API.c:1135)
==30599==    by 0xA8EC5B: zend_eval_stringl_ex (zend_execute_API.c:1176)
==30599==    by 0xA8ECE1: zend_eval_string_ex (zend_execute_API.c:1187)
==30599==    by 0xB6DF9C: do_cli (php_cli.c:1005)
==30599==    by 0xB6F064: main (php_cli.c:1344)
==30599==
==30599== LEAK SUMMARY:
==30599==    definitely lost: 128 bytes in 1 blocks
==30599==    indirectly lost: 0 bytes in 0 blocks
==30599==      possibly lost: 0 bytes in 0 blocks
==30599==    still reachable: 80,517 bytes in 41 blocks
==30599==         suppressed: 0 bytes in 0 blocks
==30599== Reachable blocks (those to which a pointer was found) are not shown.
==30599== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==30599==
==30599== For counts of detected and suppressed errors, rerun with: -v
==30599== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```

The output is clear "definitely lost: 128 bytes in 1 blocks", and it points to "zend_alloc"
functionality the function "zif_hello" in file "hello.c" line 38.
